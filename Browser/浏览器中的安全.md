> 浏览器安全主要划分为三大块内容：页面安全、系统安全和网络安全

# [页面安全]Same-origin-polity

> 如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源.
> 浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。同源策略主要表现在 DOM、Web 数据和网络这三个层面
>
> - 同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。
> - 同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据
> - 在默认情况下不能访问跨域的资源。

## 出让安全性为提高灵活性而带来的安全性问题

1. 页面中可以嵌入第三方资源 - 导致 XSS([Cross-Site Scripting](#cross-site-scripting)) 攻击
   - 内容安全策略 [Content Security Policy(CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)。CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。通过这些手段就可以大大减少 XSS 攻击。
2. 跨域资源共享和跨文档消息机制
   - 跨域资源共享（[CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。
   - 跨文档消息机制，可以通过 [window.postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) 的 JavaScript 接口来和不同源的 DOM 进行通信。

## Cross Site Scripting

XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段

- 可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息
- 可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件
- 可以通过修改 DOM 伪造假的登录窗口
- 还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验

常见的注入方式

1. 存储型 XSS 攻击(服务端的安全漏洞)

   - 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
   - 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
   - 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

2. 反射型 XSS 攻击(服务端的安全漏洞)

恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作

_Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。_

3. 基于 DOM 的 XSS 攻击(前端的安全漏洞)
   基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。

如何阻止 XSS 攻击

> 无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现

1. 服务器对输入脚本进行过滤或转码，即使返回给浏览器也不会被执行

   - 如过滤 script 标签及其内容
   - 或转码，转码之后的内容，如”script“变成“&lt;/script&gt”

2. 充分利用 CSP,CSP 的功能有

   - 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
   - 禁止向第三方域提交数据，这样用户数据也不会外泄；
   - 禁止执行内联脚本和未授权的脚本；
   - 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。

3. 通过使用 HttpOnly 属性来保护我们 Cookie 的安全。

   set-cookie 属性值最后使用了 HttpOnly 来标记该 Cookie。顾名思义，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。

## Cross-site request forgery（CSRF）

CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事

与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。
要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径。

1. 充分利用好 Cookie 的 [SameSite](https://web.dev/articles/samesite-cookies-explained) 属性
   可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。
2. 在服务器端验证请求来源的站点:HTTP 请求头中的 Referer 和 Origin 属性

   Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。

   Origin 属性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性

Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。在这里需要补充一点，Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。

3. CSRF Token

   第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。

   第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求

# [操作系统安全]安全沙箱

浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。

浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。

由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现

- 持久存储:由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，但是在渲染进程内部有访问 Cookie 的需求、有上传文件的需求，为了解决这些文件的访问需求，所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程
- 网络访问:同样有了安全沙箱的保护，在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。
- 用户交互:渲染进程不能直接访问窗口句柄
  第一点，渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。

  第二点，操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。

> 安全沙箱是不能防止 XSS 或者 CSRF 一类的攻击，
> 安全沙箱的目的是隔离渲染进程和操作系统，让渲染进行没有访问操作系统的权利
> XSS 或者 CSRF 主要是利用网络资源获取用户的信息，这和操作系统没有关系的

## 站点隔离（Site Isolation）

指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行.将标签级的渲染进程重构为 iframe 级的渲染进程，然后严格按照同一站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了

# 【网络安全】HTTPS

HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。安全层有两个主要的职责：

- 对发起 HTTP 请求的数据进行加密操作
- 对接收到 HTTP 的内容进行解密操作
