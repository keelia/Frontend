# 浏览器页面主进程（渲染进程）如何运作？
1. 采用事件循环机制：在主线程运行过程中，能接收并执行新的任务
    - 循环：线程会一直循环执行
    - 事件：可以在线程运行的过程中等待一个事件的到来，在等待中该线程处于暂停状态，一旦接受到了事件，线程被激活，执行事件
2. 使用消息队列：处理其他线程发来的任务
    - 消息队列中的[任务类型](./https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/public/platform/task_type.h)
        - 内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。
        - 页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。
    - 消息队列中的任务都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。
3. 处理其他进程发来的消息：渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面讲解的“处理其他线程发送的任务”一样了
![](./images/%E6%B8%B2%E6%9F%93%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C.webp)

## 当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？
Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时(任务是原子性的，执行了就不会中断)，判断是否有设置退出标志。如果设置了，那么就直接中断当前的所有任务，退出线程

## 页面单线程（渲染进程只有一个主线程）的缺点
*因为JavaScript引擎是运行在渲染进程的主线程上的，所以我们说JavaScript是单线程执行的！*
1. 如何处理高优先级的任务
    - 问题：因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致执行效率的下降。如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了
    - 解决：微任务权衡效率和实时性。

通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

2. 如何解决单个任务执行时长过久的问题
    - 问题：因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。
    - 解决：JavaScript引擎可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行

*用CSS3实现动画是不是不会影响主线程，和用JS实现动画会影响主线程，部分css3的动画效果是在合成线程上实现的，不需要主线程介入，所以省去了重拍和重绘的过程，这就大大提升了渲染效率。JavaScript都是在在主线程上执行的，所以JavaScript的动画需要主线程的参与，所以效率会大打折扣！*

# 浏览器页面如何运行
可以打开开发者工具，点击“Performance”标签，选择左上角的“start porfiling and load page”来记录整个页面加载过程中的事件执行情况，点击展开 Main 这个项目，其记录了主线程执行过程中的所有任务。图中灰色的就是一个个任务，每个任务下面还有子任务，其中的 Parse HTML 任务，是把 HTML 解析为 DOM 的任务。值得注意的是，**在执行 Parse HTML 的时候，如果遇到 JavaScript 脚本，那么会暂停当前的 HTML 解析而去执行 JavaScript 脚本**。

*浏览器的事件循环和js的event loop可以说是一回事，JavaScript没有自己循环系统，它依赖的就是浏览器的循环系统，也就是渲染进程提供的循环系统！*

