# 浏览器页面主进程（渲染进程）如何运作？
1. 采用事件循环机制：在主线程运行过程中，能接收并执行新的任务
    - 循环：线程会一直循环执行
    - 事件：可以在线程运行的过程中等待一个事件的到来，在等待中该线程处于暂停状态，一旦接受到了事件，线程被激活，执行事件
2. 使用消息队列：处理其他线程发来的任务
    - 消息队列中的[任务类型](./https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/public/platform/task_type.h)
        - 内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。
        - 页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。
    - 消息队列中的任务都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。
3. 处理其他进程发来的消息：渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面讲解的“处理其他线程发送的任务”一样了
![](./images/%E6%B8%B2%E6%9F%93%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C.webp)

## 当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？
Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时(任务是原子性的，执行了就不会中断)，判断是否有设置退出标志。如果设置了，那么就直接中断当前的所有任务，退出线程

## 页面单线程（渲染进程只有一个主线程）的缺点
*因为JavaScript引擎是运行在渲染进程的主线程上的，所以我们说JavaScript是单线程执行的！*
1. 如何处理高优先级的任务
    - 问题：因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致执行效率的下降。如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了
    - 解决：微任务权衡效率和实时性。

通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

2. 如何解决单个任务执行时长过久的问题
    - 问题：因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。
    - 解决：JavaScript引擎可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行

*用CSS3实现动画是不是不会影响主线程，和用JS实现动画会影响主线程，部分css3的动画效果是在合成线程上实现的，不需要主线程介入，所以省去了重拍和重绘的过程，这就大大提升了渲染效率。JavaScript都是在在主线程上执行的，所以JavaScript的动画需要主线程的参与，所以效率会大打折扣！*

# 浏览器页面如何运行
可以打开开发者工具，点击“Performance”标签，选择左上角的“start porfiling and load page”来记录整个页面加载过程中的事件执行情况，点击展开 Main 这个项目，其记录了主线程执行过程中的所有任务。图中灰色的就是一个个任务，每个任务下面还有子任务，其中的 Parse HTML 任务，是把 HTML 解析为 DOM 的任务。值得注意的是，**在执行 Parse HTML 的时候，如果遇到 JavaScript 脚本，那么会暂停当前的 HTML 解析而去执行 JavaScript 脚本**。

*浏览器的事件循环和js的event loop可以说是一回事，JavaScript没有自己循环系统，它依赖的就是浏览器的循环系统，也就是渲染进程提供的循环系统！*

# WebAPI : 浏览器如何实现setTimeout
在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。[ref-chrome队列部分源码](https://source.chromium.org/chromium/chromium/src/+/main:base/task/sequence_manager/task_queue_impl.h)
```c++
void ProcessTimerTask(){ 
    //从delayed_incoming_queue中取出已经到期的定时器任务 
    //依次执行这些任务
}
TaskQueue task_queue；
void ProcessTask();
bool keep_running = true;
void MainTherad(){ 
    for(;;){ //执行消息队列中的任务 
    Task task = task_queue.takeTask(); 
    ProcessTask(task); 
    ProcessDelayTask(); //执行延迟队列中的任务，比如有五个定时的任务到期了,那么会分别把这个五个定时器的任务执行掉，再开始下次循环过程！
    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环 
        break;
    }}
```
ProcessDelayTask 函数，该函数是专门用来处理延迟执行任务的。这里我们要重点关注它的执行时机，在上段代码中，**处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程**。通过这样的方式，一个完整的定时器就实现了。

- 延迟消息队列主要是放一些定时执行的任务，如JavaScript设置定时器的回调，还有浏览器内部的一些定时回调任务！ 这类任务需要等到指定时间间隔之后才会被执行！
-  而正常的消息队列中的任务只会按照顺序执行，执行完上个任务接着执行下个任务，不需要关心时间间隔！

*浏览器内部实现取消定时器的操作也是非常简单的，就是直接从 delayed_incoming_queue 延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了*
## 使用setTimeout的注意事项
1. 如果当前任务执行时间过久，会影响定时器任务的执行
```js
function bar() {
    console.log('bar')
}
function foo() {
    setTimeout(bar, 0);
    for (let i = 0; i < 5000; i++) {
        let i = 5+8+8+8
        console.log(i)
    }
}
foo()
```
2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒
```js
function cb() { setTimeout(cb, 0); }
setTimeout(cb, 0);
```
从performance图中可以看出，前面五次调用的时间间隔比较小，嵌套调用超过五次以上，后面每次的调用最小时间间隔是 4 毫秒。之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒.所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如你用 setTimeout 来实现 JavaScript 动画就不是一个很好的主意。函数 **requestAnimationFrame** 就是个很好的选择。

3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒

未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。

4. 延时执行时间有最大值

除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 **2147483647** 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。但如果将延时值修改为小于 2147483647 毫秒的某个值，那么执行时就没有问题了
```js
function showName(){
  console.log("极客时间")
}
var timerID = setTimeout(showName,2147483648);//会被理解调用执行
```
5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉

如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。
```js
var name= 1;
var MyObj = {
  name: 2,
  showName: function(){
    console.log(this.name);
  }
}
setTimeout(MyObj.showName,1000)
```

解决
```js
//第一种是将MyObj.showName放在匿名函数中执行，
//箭头函数
setTimeout(() => {
    MyObj.showName()
}, 1000);
//或者function函数
setTimeout(function() {
  MyObj.showName();
}, 1000)
//第二种是使用 bind 方法，将 showName 绑定在 MyObj 上面，
setTimeout(MyObj.showName.bind(MyObj), 1000)
```

## requestAnimationFrame VS setTimeout for Animation
### requestAnimationFrame
Basic WEB API for use with animation, whether that be DOM-based styling changes, canvas or WebGL.
The method in a nutshell allows you to execute code on the next available screen repaint, taking the guess work out of getting in sync with the user's browser and hardware readiness to make changes to the screen.
- raf是按照系统刷新的节奏调用的 
- raf的回调函数也是在主线程上执行的，如果其中的一个回调函数执行过久，会影响到其他的任务的
#### [Benifits for using requestAnimationFrame](https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/)
- The browser can **optimize concurrent animations together into a single** reflow and repaint cycle, leading to higher fidelity animation. For example, JS-based animations synchronized with CSS transitions or SVG SMIL. *That is: animations with requestAnimationFrame are non-blocking, which means if you make subsequent calls to requestAnimationFrame, the resulting animations will all occur at same time.*
- If you’re running the animation loop in a tab that’s not visible, the browser won’t keep it running, which means less CPU, GPU, and memory usage, leading to much longer battery life.

#### [Bad for using setTimeout/setInterval](http://javascriptkit.com/javatutors/requestanimationframe.shtml)
- Unstable Delay : What we specify as the delay (ie: 50 milliseconds) inside these functions are often times not honoured due to changes in user system resources at the time, leading to inconsistent delay intervals between animation frames.
- Layout thrashing on invisible Tab: using setTimeout() or setInterval() to continuously make changes to the user's screen often induces "layout thrashing", the browser version of cardiac arrest where it is forced to perform unnecessary reflows of the page before the user's screen is physically able to display the changes. 
