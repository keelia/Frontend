# JavaScript 内存机制
- 弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。
- 动态，意味着你可以使用同一个变量保存不同类型的数据。

静态语言 VS 动态语言
- 静态语言:在使用之前就需要确认其变量数据类型
- 动态语言:在运行过程中需要检查数据类型的语言

强类型语言 VS 弱类型语言
- 强类型语言：不支持隐式类型转换的语言称为强类型语言
- 弱类型语言： 支持隐式类型转换的语言称为弱类型语言

栈空间：储存原始类型 ；堆空间：储存引用类型。JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据

## 闭包如何产生
```js
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```
产生闭包的核心有两步：
- 第一步是需要预扫描内部函数；
- 第二步是把内部函数引用的外部变量保存到堆中：由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存所引用的外部函数的变量。当执行到 foo 函数时，闭包就产生了，即使外部函数退出了，“ closure(foo)”依然被外部函数内部的方法引用。所以在下次调用外部函数返回的方法时，创建的执行上下文中就包含了“closure(foo)”。

chrome查询闭包：
1. 打开“开发者工具”
2. 在控制台执行上述代码
3. 然后选择“Memory”标签，点击"take snapshot" 获取V8的堆内存快照。
4. 然后“command+f"(mac) 或者 "ctrl+f"(win),搜索“setName”，然后你就会发现setName对象下面包含了 raw_outer_scope_info_or_feedback_metadata，对闭包的引用数据就在这里面。

## [完整copy对象](./copy%20object.js)
```js
let jack = {
    name : "jack.ma",
    age:40,
    like:{
        dog:{
            color:'black',
            age:3,
        },
        cat:{
            color:'white',
            age:2
        }
    }
}
function copy(src){
    let dest
    //实现拷贝代码，将src的值完整地拷贝给dest
   //在这里实现
    return dest
}
let jack2 = copy(jack)

//比如修改jack2中的内容，不会影响到jack中的值
jack2.like.dog.color = 'green'
console.log(jack.like.dog.color) //打印出来的应该是 "black"
```


